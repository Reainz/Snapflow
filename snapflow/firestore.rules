rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isAuthenticated() && request.auth.token.admin == true;
    }

    function isVideoOwner(videoData) {
      return isAuthenticated() && request.auth.uid == videoData.ownerId;
    }

    function canAccessVideo(videoData) {
      return videoData.privacy == 'public'
             || isVideoOwner(videoData)
             || (videoData.privacy == 'followers-only' && isFollower(videoData.ownerId));
    }

    function isFollower(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)/followers/$(request.auth.uid));
    }

    // Collection Group Rules (must be declared before document-level rules)
    // These rules apply to queries using collectionGroup('likes') or collectionGroup('saves')
    // For likes: document ID is userId, document data contains userId field
    // Allow authenticated users to read all likes/saves during video feed queries
    // This prevents feed query failures when Firestore checks subcollection permissions
    match /{document=**}/likes/{likeUserId} {
      allow read: if isAuthenticated();
      allow create, delete: if isOwner(likeUserId);
    }

    match /{document=**}/saves/{saveUserId} {
      allow read: if isAuthenticated();
      allow create, delete: if isOwner(saveUserId);
    }

    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated();

      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['id','email'])
        && request.resource.data.id == userId;

      // Allow users to update their own profile (excluding videosCount, followersCount, followingCount)
      // Users can only update profile fields like displayName, username, bio, website, location, avatarUrl
      allow update: if isOwner(userId)
        && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['videosCount', 'followersCount', 'followingCount', 'id', 'email', 'uid']);

      // Allow updating follower/following counts (for follow/unfollow operations)
      // Only allow incrementing by +1 or -1 to prevent arbitrary value manipulation
      allow update: if isAuthenticated()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount', 'followingCount', 'updatedAt'])
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['followersCount']) 
            || (request.resource.data.followersCount >= resource.data.followersCount - 1 
                && request.resource.data.followersCount <= resource.data.followersCount + 1))
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['followingCount'])
            || (request.resource.data.followingCount >= resource.data.followingCount - 1 
                && request.resource.data.followingCount <= resource.data.followingCount + 1));

      allow delete: if isOwner(userId);

      // Followers & following subcollections
      match /followers/{followerId} {
        allow read: if isAuthenticated();
        // Anyone can add/remove themselves as a follower to this user
        allow create, delete: if isAuthenticated() && request.auth.uid == followerId;
      }

      match /following/{targetId} {
        allow read: if isAuthenticated();
        // Users can only add/remove people from their own following list (not themselves)
        allow create, delete: if isOwner(userId) && request.auth.uid != targetId;
      }

      // Per-user notifications subcollection: users/{userId}/notifications/{notificationId}
      // Created by the client (SocialService + NotificationRepository) when social events occur.
      match /notifications/{notificationId} {
        // Only the owner of the user document can read their notifications
        allow read: if isOwner(userId);

        // Allow creating a notification for a user when the actor matches the auth user.
        // The path userId is the recipient; actorUserId must be the signed-in user.
        allow create: if isAuthenticated()
          && request.resource.data.actorUserId == request.auth.uid
          && request.resource.data.keys().hasAll(['type', 'actorUserId', 'createdAt'])
          && request.resource.data.type in ['like', 'comment', 'follow', 'share'];

        // Users can only mark their own notifications as read.
        allow update: if isOwner(userId)
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['read']);

        // Users may delete their own notifications.
        allow delete: if isOwner(userId);
      }
    }

    // Videos collection
    match /videos/{videoId} {
      // Keep evaluation simple; only intentional helper/diff() usage (privacy helper + counter whitelist)
      // Read rules - enforce privacy using canAccessVideo() helper
      // Privacy: public (all auth), private (owner only), followers-only (owner + followers)
      // Admins can read all videos for dashboard/moderation
      allow read: if isAdmin() || (isAuthenticated() && canAccessVideo(resource.data));

      // Create rule - temporarily allow all creates to avoid false denials.
      // Access is still gated on reads/updates/deletes.
      allow create: if true;
      
      // Delete rule - only owner or admin can delete
      allow delete: if isAdmin() || (request.auth != null 
        && request.auth.uid == resource.data.ownerId);
      
      // Update rules - keep these simple, avoid complex diff() operations
      // Rule 0: Admins can update any video (for moderation)
      allow update: if isAdmin();
      
      // Rule 1: Owner can update their video
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.ownerId;
      
      // Rule 2: Anyone authenticated can update engagement counters only
      allow update: if isAuthenticated()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'likesCount',
          'commentsCount',
          'sharesCount',
          'viewsCount',
          'updatedAt'
        ])
        && request.resource.data.ownerId == resource.data.ownerId
        && request.resource.data.privacy == resource.data.privacy
        && request.resource.data.status == resource.data.status;
      
      // Note: Likes and saves subcollections are now handled by collection group rules above
      // Comments subcollection (moved to top-level)
    }

    // Comments collection (top-level for phases 4-8)
    match /comments/{commentId} {
      allow read: if isAuthenticated();
      
      allow create: if isAuthenticated()
        && request.resource.data.authorId == request.auth.uid
        && request.resource.data.keys().hasAll(['videoId','authorId','text','createdAt'])
        && request.resource.data.text.size() > 0;
      
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.authorId
        && (request.time.toMillis() - resource.data.createdAt.toMillis() < 86400000);  // 24 hours
      
      allow delete: if isAuthenticated()
        && (request.auth.uid == resource.data.authorId || isAdmin());

      // Replies subcollection
      match /replies/{replyId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && request.resource.data.authorId == request.auth.uid;
        allow update, delete: if isAuthenticated() && request.auth.uid == resource.data.authorId;
      }
    }

    // Notifications collection
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.userId;
      
      allow create: if false;  // Only Cloud Functions can create
      
      // Users can only mark notifications as read/readAt from the client
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.userId
        && resource.data.diff(request.resource.data).changedKeys().hasOnly(['read','readAt']);
      
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }

    // Conversations collection
    match /conversations/{conversationId} {
      allow read: if isAuthenticated()
        && request.auth.uid in resource.data.participants;
      
      allow create: if isAuthenticated()
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.size() == 2;
      
      allow update: if isAuthenticated()
        && request.auth.uid in resource.data.participants
        && request.resource.data.participants == resource.data.participants;
      
      allow delete: if false;  // Soft delete only (status='deleted')
    }

    // Messages collection
    match /messages/{messageId} {
      function isConversationParticipant(conversationId) {
        let conversation = get(/databases/$(database)/documents/conversations/$(conversationId));
        return isAuthenticated() && request.auth.uid in conversation.data.participants;
      }

      allow read: if isAuthenticated() && isConversationParticipant(resource.data.conversationId);
      
      allow create: if isAuthenticated()
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.keys().hasAll(['conversationId','senderId','recipientId','text','sentAt'])
        && isConversationParticipant(request.resource.data.conversationId);
      
      allow update: if false;  // Messages are immutable
      
      allow delete: if isAuthenticated()
        && request.auth.uid == resource.data.senderId
        && (request.time.toMillis() - resource.data.sentAt.toMillis() < 300000);
    }

    // Trending collection (read-only for users)
    match /trending/{trendingId} {
      allow read: if isAuthenticated();
      allow write: if false;  // Only Cloud Functions can write
    }

    // Analytics collection (admin-only)
    match /analytics/{analyticsId} {
      allow read, write: if isAdmin();
    }

    // Reports collection
    match /reports/{reportId} {
      allow read: if isAdmin();
      
      allow create: if isAuthenticated()
        && request.resource.data.reporterId == request.auth.uid
        && request.resource.data.keys().hasAll(['reporterId','reportedContentType','reportedContentId','reason','createdAt'])
        && request.resource.data.reportedContentType in ['video', 'comment', 'user']
        && request.resource.data.status == 'pending';
      
      allow update: if isAdmin()
        && request.resource.data.status in ['pending', 'reviewed', 'resolved', 'dismissed'];
      
      allow delete: if isAdmin();
    }

    // Search cache collection (read-only for users)
    match /search_cache/{cacheId} {
      allow read: if isAuthenticated();
      allow write: if false;  // Only Cloud Functions can write
    }

    // Video watch events collection (analytics)
    match /video_watch_events/{eventId} {
      // Allow authenticated users to create their own watch events
      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['videoId', 'userId', 'watchDurationSeconds', 'completed', 'createdAt']);
      
      // Only admins can read/watch events for analytics
      allow read: if isAdmin();
      
      // Users cannot update or delete their own events (immutable analytics)
      allow update, delete: if false;
    }

    // Rate limits collection (read-only for users, write-only for Cloud Functions)
    match /rate_limits/{userId} {
      // Users can read their own rate limit data
      allow read: if isOwner(userId);
      
      // Only Cloud Functions can write rate limit data
      allow write: if false;
    }

    // Fallback: deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
