// Snapflow Demo Data Seeding Script
// Creates 46 demo user accounts and 111 demo videos for testing
// 
// Requirements:
// - Node 18+
// - Env: GOOGLE_APPLICATION_CREDENTIALS points to a service account JSON with Firebase Admin
// - Env: FIREBASE_PROJECT_ID (optional, defaults to snapflow-4577d)
//
// Usage:
//   node seed_demo_data.mjs

import fs from 'node:fs';
import process from 'node:process';
import admin from 'firebase-admin';

/**
 * Utility: Require environment variable
 */
function requireEnv(name) {
  const v = process.env[name];
  if (!v) throw new Error(`Missing environment variable: ${name}`);
  return v;
}

/**
 * Utility: Initialize Firebase Admin SDK
 */
async function initializeFirebase() {
  const projectId = process.env.FIREBASE_PROJECT_ID || 'snapflow-4577d';
  const creds = requireEnv('GOOGLE_APPLICATION_CREDENTIALS');
  
  if (!fs.existsSync(creds)) {
    throw new Error(`Service account file not found: ${creds}`);
  }

  if (admin.apps.length === 0) {
    admin.initializeApp({
      credential: admin.credential.applicationDefault(),
      projectId,
    });
  }

  console.log(`‚úÖ Firebase Admin SDK initialized for project: ${projectId}`);
  
  const bucketName = process.env.FIREBASE_STORAGE_BUCKET || `${projectId}.firebasestorage.app`;
  const bucket = admin.storage().bucket(bucketName);
  
  return { projectId, db: admin.firestore(), auth: admin.auth(), bucket };
}

/**
 * Step 2: Delete E2E Test Videos
 * Removes all videos with IDs starting with 'e2e_' and related data
 * Also performs complete storage wipe of test data
 */
async function deleteE2ETestVideos(db, bucket) {
  console.log('\nüìã Step 2: Deleting E2E test videos and related data...');
  
  try {
    // First, clean up orphaned comments (comments for videos that no longer exist)
    console.log('   üîç Cleaning up orphaned comments...');
    const allCommentsSnapshot = await db.collection('comments').get();
    let orphanedCount = 0;
    
    for (const commentDoc of allCommentsSnapshot.docs) {
      const commentData = commentDoc.data();
      const videoId = commentData.videoId;
      
      if (videoId && videoId.startsWith('e2e_')) {
        await commentDoc.ref.delete();
        orphanedCount++;
        console.log(`   üóëÔ∏è  Deleted orphaned comment ${commentDoc.id} for E2E video ${videoId}`);
      }
    }
    
    if (orphanedCount > 0) {
      console.log(`   ‚úÖ Cleaned up ${orphanedCount} orphaned comments`);
    } else {
      console.log(`   ‚ÑπÔ∏è  No orphaned comments found`);
    }
    
    // Complete storage wipe - delete ALL files from video-related folders
    console.log('   üîç Performing complete storage wipe (all test data)...');
    // Flow B: processed assets live in Cloudinary, not Firebase Storage
    const storageFolders = ['thumbnails', 'captions', 'raw-videos'];
    let storageFilesDeleted = 0;
    
    for (const folder of storageFolders) {
      try {
        const [allFiles] = await bucket.getFiles({ prefix: `${folder}/` });
        
        if (allFiles.length === 0) {
          console.log(`   üìÅ ${folder}/ is already empty`);
          continue;
        }
        
        console.log(`   üìÅ Deleting ${allFiles.length} files from ${folder}/...`);
        
        // Delete files in batches to avoid memory issues
        const batchSize = 100;
        for (let i = 0; i < allFiles.length; i += batchSize) {
          const batch = allFiles.slice(i, i + batchSize);
          await Promise.all(batch.map(file => file.delete()));
          storageFilesDeleted += batch.length;
          
          if (allFiles.length > batchSize) {
            console.log(`      Deleted ${Math.min(i + batchSize, allFiles.length)}/${allFiles.length} files`);
          }
        }
        
        console.log(`   ‚úÖ Deleted all ${allFiles.length} files from ${folder}/`);
      } catch (error) {
        console.error(`   ‚ö†Ô∏è  Error cleaning ${folder}: ${error.message}`);
      }
    }
    
    console.log(`   ‚úÖ Total storage files deleted: ${storageFilesDeleted}`);
    
    // Clean up analytics collection (regenerated by Cloud Functions)
    console.log('   üîç Cleaning up analytics collection...');
    const analyticsSnapshot = await db.collection('analytics').get();
    let analyticsDeleted = 0;
    
    if (analyticsSnapshot.empty) {
      console.log('   ‚ÑπÔ∏è  Analytics collection is already empty');
    } else {
      console.log(`   üìä Deleting ${analyticsSnapshot.size} analytics documents...`);
      const batchSize = 500; // Firestore batch limit
      
      for (let i = 0; i < analyticsSnapshot.docs.length; i += batchSize) {
        const batch = db.batch();
        const batchDocs = analyticsSnapshot.docs.slice(i, i + batchSize);
        batchDocs.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        analyticsDeleted += batchDocs.length;
        
        if (analyticsSnapshot.size > batchSize) {
          console.log(`      Deleted ${Math.min(i + batchSize, analyticsSnapshot.size)}/${analyticsSnapshot.size} analytics docs`);
        }
      }
      
      console.log(`   ‚úÖ Deleted ${analyticsDeleted} analytics documents`);
    }
    
    // Query all videos with e2e_ prefix
    const videosSnapshot = await db.collection('videos').get();
    const e2eVideos = videosSnapshot.docs.filter(doc => doc.id.startsWith('e2e_'));
    
    if (e2eVideos.length === 0) {
      console.log('   ‚ÑπÔ∏è  No E2E test videos found to delete');
      return { deleted: 0, orphanedComments: orphanedCount, storageFiles: storageFilesDeleted, analyticsFiles: analyticsDeleted, errors: [] };
    }

    console.log(`   Found ${e2eVideos.length} E2E test videos to delete`);
    
    const deleted = [];
    const errors = [];
    const e2eVideoIds = e2eVideos.map(doc => doc.id);

    // Delete comments from the root-level comments collection
    console.log('   üîç Checking root-level comments collection...');
    for (const videoId of e2eVideoIds) {
      try {
        const commentsSnapshot = await db.collection('comments')
          .where('videoId', '==', videoId)
          .get();
        
        if (!commentsSnapshot.empty) {
          const batch = db.batch();
          commentsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
          await batch.commit();
          console.log(`   üóëÔ∏è  Deleted ${commentsSnapshot.size} comments from root collection for video ${videoId}`);
        }
      } catch (error) {
        console.error(`   ‚ö†Ô∏è  Error deleting root comments for ${videoId}: ${error.message}`);
      }
    }

    // Now delete each video and its subcollections
    for (const videoDoc of e2eVideos) {
      const videoId = videoDoc.id;
      try {
        // Delete subcollections (likes, comments, saves)
        const subcollections = ['likes', 'comments', 'saves'];
        
        for (const subcollection of subcollections) {
          const subcollectionRef = db.collection('videos').doc(videoId).collection(subcollection);
          const subcollectionSnapshot = await subcollectionRef.get();
          
          if (!subcollectionSnapshot.empty) {
            const batch = db.batch();
            subcollectionSnapshot.docs.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
            console.log(`   üóëÔ∏è  Deleted ${subcollectionSnapshot.size} documents from videos/${videoId}/${subcollection}`);
          }
        }

        // Delete the video document itself
        await videoDoc.ref.delete();
        deleted.push(videoId);
        console.log(`   ‚úÖ Deleted video: ${videoId}`);
      } catch (error) {
        errors.push({ videoId, error: error.message });
        console.error(`   ‚ùå Failed to delete video ${videoId}: ${error.message}`);
      }
    }

    console.log(`\n   Summary: Deleted ${deleted.length} E2E test videos, ${orphanedCount} orphaned comments, ${storageFilesDeleted} storage files, and ${analyticsDeleted} analytics documents`);
    if (errors.length > 0) {
      console.log(`   ‚ö†Ô∏è  ${errors.length} errors encountered`);
    }

    return { deleted: deleted.length, orphanedComments: orphanedCount, storageFiles: storageFilesDeleted, analyticsFiles: analyticsDeleted, errors };
  } catch (error) {
    console.error(`   ‚ùå Error in deleteE2ETestVideos: ${error.message}`);
    throw error;
  }
}

/**
 * Step 3: Create Demo User Accounts
 * Creates 46 demo users with Firebase Auth and Firestore profiles
 * Sets up follower relationships between users
 */
async function createDemoUsers(db, auth) {
  console.log('\nüìã Step 3: Creating demo user accounts...');
  
  // Define demo users with complete profile information
  // IMPORTANT: Bidirectional consistency enforced - if A follows B, then B's followers includes A
  const baseUsers = [
    {
      email: 'demo1@snapflow.test',
      password: 'Demo123!',
      username: 'alexcreator',
      displayName: 'Alex Creator',
      bio: 'Content creator | Travel enthusiast | Sharing my adventures',
      location: 'San Francisco, CA',
      website: '',
      followers: ['samexplorer', 'jordanartist', 'rileyfoodie'], // usernames who follow this user
      following: ['samexplorer', 'jordanartist', 'taylorfitness'], // usernames this user follows
    },
    {
      email: 'demo2@snapflow.test',
      password: 'Demo123!',
      username: 'samexplorer',
      displayName: 'Sam Explorer',
      bio: 'Exploring the world one video at a time üåç',
      location: 'New York, NY',
      website: '',
      followers: ['alexcreator', 'jordanartist', 'morgantech'],
      following: ['alexcreator', 'jordanartist', 'morgantech'],
    },
    {
      email: 'demo3@snapflow.test',
      password: 'Demo123!',
      username: 'jordanartist',
      displayName: 'Jordan Artist',
      bio: 'Digital artist sharing my creative journey üé®',
      location: 'Los Angeles, CA',
      website: '',
      followers: ['alexcreator', 'samexplorer'],
      following: ['alexcreator', 'samexplorer'],
    },
    {
      email: 'demo4@snapflow.test',
      password: 'Demo123!',
      username: 'taylorfitness',
      displayName: 'Taylor Fitness',
      bio: 'Fitness coach | Healthy lifestyle tips üí™',
      location: 'Miami, FL',
      website: '',
      followers: ['alexcreator', 'morgantech'],
      following: ['morgantech'],
    },
    {
      email: 'demo5@snapflow.test',
      password: 'Demo123!',
      username: 'morgantech',
      displayName: 'Morgan Tech',
      bio: 'Tech enthusiast | Coding tutorials | App development',
      location: 'Seattle, WA',
      website: '',
      followers: ['samexplorer', 'taylorfitness'],
      following: ['samexplorer', 'taylorfitness'],
    },
    {
      email: 'demo6@snapflow.test',
      password: 'Demo123!',
      username: 'rileyfoodie',
      displayName: 'Riley Foodie',
      bio: 'Food blogger | Recipe creator | Culinary adventures üç≥',
      location: 'Chicago, IL',
      website: '',
      followers: [],
      following: ['alexcreator'],
    },
  ];

  // Generate 40 additional demo users with varied names, bios, and locations
  const firstNames = ['Avery', 'Blake', 'Casey', 'Drew', 'Emerson', 'Harper', 'Jamie', 'Kai', 'Logan', 'Morgan', 'Parker', 'Reese', 'Sawyer', 'Taylor', 'Quinn', 'Rowan', 'Skyler', 'Sydney', 'Teagan', 'Riley'];
  const lastNames = ['Wright', 'Lee', 'Rivera', 'Patel', 'Nguyen', 'Kim', 'Lopez', 'Jordan', 'Parker', 'Shaw', 'Hayes', 'Carter', 'Brooks', 'Reid', 'Miller', 'Davis', 'Edwards', 'Harris', 'Clark', 'Adams'];
  const cities = ['Austin, TX', 'Seattle, WA', 'Denver, CO', 'Brooklyn, NY', 'Portland, OR', 'Toronto, CA', 'London, UK', 'Sydney, AU', 'Vancouver, CA', 'Chicago, IL', 'Los Angeles, CA', 'Atlanta, GA'];
  const roles = ['Product designer', 'Mobile dev', 'Data analyst', 'Travel vlogger', 'Food blogger', 'Fitness coach', 'Student', 'Photographer', 'UI engineer', 'Creator'];
  const interests = ['coffee', 'street photography', 'bouldering', 'cycling', 'minimal setups', 'urban hikes', 'brunch spots', 'art fairs', 'sunrise runs', 'recipe testing', 'studio lighting', 'cinematic b-roll'];

  const extraUsers = Array.from({ length: 40 }, (_, idx) => {
    const first = firstNames[idx % firstNames.length];
    const last = lastNames[(idx * 3) % lastNames.length];
    const city = cities[idx % cities.length];
    const role = roles[(idx * 2) % roles.length];
    const interest = interests[(idx * 5) % interests.length];
    const usernameBase = `${first}${last}`.toLowerCase().replace(/\s+/g, '');
    const username = `${usernameBase}${(idx % 7) + 1}`;
    const num = (idx + 1).toString().padStart(2, '0');

    return {
      email: `demo_extra${num}@snapflow.test`,
      password: 'Demo123!',
      username,
      displayName: `${first} ${last}`,
      bio: `${role} | ${interest} | ${city}`,
      location: city,
      website: `https://linktr.ee/${username}`,
      followers: [],
      following: [],
    };
  });

  const demoUsers = [...baseUsers, ...extraUsers];

  // Build a random-but-consistent follow graph so new accounts are connected to the originals.
  const allUsernames = demoUsers.map((u) => u.username);
  const baseUsernames = baseUsers.map((u) => u.username);

  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const shuffle = (arr) => arr
    .map((v) => ({ v, sort: Math.random() }))
    .sort((a, b) => a.sort - b.sort)
    .map(({ v }) => v);

  // Initialize follow sets
  const followGraph = new Map(allUsernames.map((u) => [u, new Set()]));

  // Seed the original curated relationships
  for (const user of baseUsers) {
    const followingSet = followGraph.get(user.username);
    user.following.forEach((f) => {
      if (f !== user.username && followGraph.has(f)) {
        followingSet.add(f);
      }
    });
    user.followers.forEach((f) => {
      if (f !== user.username && followGraph.has(f)) {
        followGraph.get(f).add(user.username);
      }
    });
  }

  // Add randomized connections to mix old and new accounts
  for (const user of demoUsers) {
    const desired = baseUsernames.includes(user.username) ? randInt(4, 8) : randInt(3, 7);
    const candidates = shuffle(allUsernames.filter((u) => u !== user.username));

    // Ensure each user follows at least one original account (if not themselves)
    const baseCandidates = shuffle(baseUsernames.filter((b) => b !== user.username));
    if (baseCandidates.length > 0) {
      followGraph.get(user.username).add(baseCandidates[0]);
    }

    for (const candidate of candidates) {
      if (followGraph.get(user.username).size >= desired) break;
      followGraph.get(user.username).add(candidate);
    }
  }

  // Derive followers from the follow graph
  const followersMap = new Map(allUsernames.map((u) => [u, new Set()]));
  for (const [follower, followees] of followGraph.entries()) {
    for (const followee of followees) {
      followersMap.get(followee)?.add(follower);
    }
  }

  // Materialize following/followers arrays for seeding
  for (const user of demoUsers) {
    user.following = Array.from(followGraph.get(user.username) || []);
    user.followers = Array.from(followersMap.get(user.username) || []);
  }

  const createdUsers = [];
  const errors = [];
  const userIdMap = {}; // Map usernames to UIDs

  // Step 3.1: Create Firebase Auth accounts and Firestore user documents
  console.log('   üìù Creating Firebase Auth accounts and user profiles...');
  
  for (const userData of demoUsers) {
    try {
      // Check if user already exists
      let userRecord;
      try {
        userRecord = await auth.getUserByEmail(userData.email);
        console.log(`   ‚ÑπÔ∏è  User ${userData.email} already exists (UID: ${userRecord.uid})`);
      } catch (error) {
        if (error.code === 'auth/user-not-found') {
          // Create new Firebase Auth user
          userRecord = await auth.createUser({
            email: userData.email,
            password: userData.password,
            displayName: userData.displayName,
            emailVerified: true, // Auto-verify for demo accounts
          });
          console.log(`   ‚úÖ Created Firebase Auth user: ${userData.email} (UID: ${userRecord.uid})`);
        } else {
          throw error;
        }
      }

      // Store UID mapping for follower relationships
      userIdMap[userData.username] = userRecord.uid;

      // Create Firestore user profile document
      const userProfileData = {
        uid: userRecord.uid,
        email: userData.email,
        username: userData.username,
        displayName: userData.displayName,
        displayNameLower: userData.displayName.toLowerCase(),
        bio: userData.bio,
        location: userData.location,
        website: userData.website,
        avatarUrl: '', // Placeholder - will be empty/default avatar
        coverPhotoURL: '',
        videosCount: 0, // Will be updated when videos are created
        followersCount: 0, // Will be updated when followers are added
        followingCount: 0, // Will be updated when followers are added
        likesCount: 0,
        isVerified: false,
        isAdmin: false,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        // Geographic data (optional)
        countryCode: 'US',
        region: 'North America',
      };

      // Check if user document already exists
      const userDocRef = db.collection('users').doc(userRecord.uid);
      const userDoc = await userDocRef.get();
      
      if (userDoc.exists) {
        // Update existing user document
        await userDocRef.update({
          ...userProfileData,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        console.log(`   ‚ôªÔ∏è  Updated Firestore profile for ${userData.username}`);
      } else {
        // Create new user document
        await userDocRef.set(userProfileData);
        console.log(`   ‚úÖ Created Firestore profile for ${userData.username}`);
      }

      createdUsers.push({
        uid: userRecord.uid,
        email: userData.email,
        username: userData.username,
        followers: userData.followers,
        following: userData.following,
      });

    } catch (error) {
      errors.push({ email: userData.email, error: error.message });
      console.error(`   ‚ùå Failed to create user ${userData.email}: ${error.message}`);
    }
  }

  // Step 3.2: Create follower relationships
  console.log('\n   üìù Setting up follower relationships...');
  
  for (const user of createdUsers) {
    try {
      const userId = user.uid;
      
      // Create followers subcollection (users who follow this user)
      for (const followerUsername of user.followers) {
        const followerId = userIdMap[followerUsername];
        if (!followerId) {
          console.warn(`   ‚ö†Ô∏è  Follower ${followerUsername} not found for user ${user.username}`);
          continue;
        }

        const followerDocRef = db.collection('users').doc(userId).collection('followers').doc(followerId);
        await followerDocRef.set({
          userId: followerId,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        console.log(`   ‚úÖ Added ${followerUsername} as follower of ${user.username}`);
      }

      // Create following subcollection (users this user follows)
      for (const followingUsername of user.following) {
        const followingId = userIdMap[followingUsername];
        if (!followingId) {
          console.warn(`   ‚ö†Ô∏è  Following user ${followingUsername} not found for user ${user.username}`);
          continue;
        }

        const followingDocRef = db.collection('users').doc(userId).collection('following').doc(followingId);
        await followingDocRef.set({
          userId: followingId,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        console.log(`   ‚úÖ ${user.username} now follows ${followingUsername}`);
      }

      // Update follower/following counts
      await db.collection('users').doc(userId).update({
        followersCount: user.followers.length,
        followingCount: user.following.length,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      console.log(`   ‚úÖ Updated counts for ${user.username}: ${user.followers.length} followers, ${user.following.length} following`);

    } catch (error) {
      errors.push({ username: user.username, error: error.message });
      console.error(`   ‚ùå Failed to set up relationships for ${user.username}: ${error.message}`);
    }
  }

  console.log(`\n   Summary: Created ${createdUsers.length} demo user accounts with follower relationships`);
  if (errors.length > 0) {
    console.log(`   ‚ö†Ô∏è  ${errors.length} errors encountered`);
  }

  return { created: createdUsers.length, userIdMap, errors };
}

/**
 * Step 4: Create Demo Videos
 * Creates 111 demo videos with complete metadata, privacy settings, and engagement metrics
 */
async function createDemoVideos(db, userIdMap) {
  console.log('\nüìã Step 4: Creating demo videos...');
  
  // Define demo videos with complete metadata
  // Engagement values are bounded to realistic demo-only ranges
  const baseVideos = [
    {
      id: 'demo_video_001',
      ownerUsername: 'alexcreator',
      title: 'Sunset in San Francisco',
      description: 'Beautiful sunset over the Golden Gate Bridge üåâ #sunset #sanfrancisco #travel',
      hashtags: ['#sunset', '#sanfrancisco', '#travel', '#goldengate'],
      privacy: 'public',
      durationSeconds: 45,
      likes: 5, // Adjusted to realistic maximum (6 users - 1 owner = 5)
      comments: 5,
      views: 150,
      shares: 3,
    },
    {
      id: 'demo_video_002',
      ownerUsername: 'alexcreator',
      title: 'Morning Workout Routine',
      description: 'Starting the day with energy! üí™ #fitness #workout #motivation',
      hashtags: ['#fitness', '#workout', '#motivation', '#health'],
      privacy: 'public',
      durationSeconds: 30,
      likes: 4, // Realistic engagement
      comments: 3,
      views: 120,
      shares: 2,
    },
    {
      id: 'demo_video_003',
      ownerUsername: 'samexplorer',
      title: 'Exploring Central Park',
      description: 'A peaceful walk through Central Park in autumn üçÇ #newyork #centralpark #nature',
      hashtags: ['#newyork', '#centralpark', '#nature', '#autumn'],
      privacy: 'public',
      durationSeconds: 50,
      likes: 5, // Adjusted to realistic maximum
      comments: 5,
      views: 200,
      shares: 5,
    },
    {
      id: 'demo_video_004',
      ownerUsername: 'samexplorer',
      title: 'Hidden Gems in NYC',
      description: 'Sharing some secret spots only locals know about ü§´ #newyork #local #explore',
      hashtags: ['#newyork', '#local', '#explore', '#hidden'],
      privacy: 'followers-only',
      durationSeconds: 40,
      likes: 4, // Realistic engagement for followers-only
      comments: 4,
      views: 80,
      shares: 1,
    },
    {
      id: 'demo_video_005',
      ownerUsername: 'jordanartist',
      title: 'Digital Art Process',
      description: 'Time-lapse of my latest digital painting üé® #digitalart #art #creative',
      hashtags: ['#digitalart', '#art', '#creative', '#painting'],
      privacy: 'public',
      durationSeconds: 35,
      likes: 5, // Adjusted to realistic maximum
      comments: 5,
      views: 280,
      shares: 5,
    },
    {
      id: 'demo_video_006',
      ownerUsername: 'jordanartist',
      title: 'Color Palette Inspiration',
      description: 'Finding colors in everyday life üåà #colors #inspiration #design',
      hashtags: ['#colors', '#inspiration', '#design', '#aesthetic'],
      privacy: 'public',
      durationSeconds: 25,
      likes: 5, // Adjusted to realistic maximum
      comments: 4,
      views: 180,
      shares: 4,
    },
    {
      id: 'demo_video_007',
      ownerUsername: 'taylorfitness',
      title: 'Quick HIIT Workout',
      description: '15-minute high-intensity workout you can do anywhere! üî• #hiit #fitness #workout',
      hashtags: ['#hiit', '#fitness', '#workout', '#exercise'],
      privacy: 'public',
      durationSeconds: 30,
      likes: 5, // Adjusted to realistic maximum
      comments: 5,
      views: 250,
      shares: 5,
    },
    {
      id: 'demo_video_008',
      ownerUsername: 'taylorfitness',
      title: 'Healthy Meal Prep',
      description: 'Sunday meal prep for the week ü•ó #mealprep #healthy #nutrition',
      hashtags: ['#mealprep', '#healthy', '#nutrition', '#food'],
      privacy: 'public',
      durationSeconds: 40,
      likes: 4, // Realistic engagement
      comments: 3,
      views: 160,
      shares: 3,
    },
    {
      id: 'demo_video_009',
      ownerUsername: 'morgantech',
      title: 'Coding Setup Tour',
      description: 'My development workspace and tools üíª #coding #setup #developer',
      hashtags: ['#coding', '#setup', '#developer', '#tech'],
      privacy: 'public',
      durationSeconds: 35,
      likes: 3, // Realistic engagement
      comments: 2,
      views: 140,
      shares: 2,
    },
    {
      id: 'demo_video_010',
      ownerUsername: 'morgantech',
      title: 'App Development Tips',
      description: 'Quick tips for Flutter development üöÄ #flutter #appdev #tips',
      hashtags: ['#flutter', '#appdev', '#tips', '#programming'],
      privacy: 'private',
      durationSeconds: 30,
      likes: 0, // Private video - no engagement
      comments: 0,
      views: 0,
      shares: 0,
    },
    {
      id: 'demo_video_011',
      ownerUsername: 'rileyfoodie',
      title: 'Homemade Pasta Recipe',
      description: 'Making fresh pasta from scratch! üçù #pasta #recipe #cooking #homemade',
      hashtags: ['#pasta', '#recipe', '#cooking', '#homemade'],
      privacy: 'public',
      durationSeconds: 50,
      likes: 5, // Adjusted to realistic maximum
      comments: 5,
      views: 300,
      shares: 5,
    },
  ];

  // Generate 100 additional demo videos spread across all demo users with richer content
  const ownerUsernames = Object.keys(userIdMap);
  const categories = ['travel', 'fitness', 'art', 'tech', 'food', 'lifestyle', 'music', 'learn', 'fashion', 'general'];
  const places = ['Lisbon', 'Kyoto', 'Berlin', 'Barcelona', 'Seoul', 'Mexico City', 'Copenhagen', 'Bali', 'Istanbul', 'Cape Town', 'Reykjavik', 'Vancouver', 'Denver', 'Austin'];
  const foodIdeas = ['ramen night', 'taco crawl', 'sourdough bake', 'street food tour', 'meal prep', 'quick pasta', 'brunch spread', 'farmers market haul'];
  const techIdeas = ['Flutter tips', 'clean architecture', 'state management', 'design systems', 'CI/CD setup', 'VS Code hacks', 'API testing', 'animation tricks'];
  const fitnessIdeas = ['sunrise run', 'HIIT finisher', 'mobility flow', 'leg day staples', 'core burner', 'cycle session', 'trail hike'];
  const artIdeas = ['color grading', 'sketchbook tour', 'photo walk', 'cinematic b-roll', 'poster design', 'procreate timelapse', 'portrait retouch'];
  const lifestyleIdeas = ['desk setup refresh', 'morning routine', 'packing list', 'weekend reset', 'book haul', 'plant care', 'budget tips'];

  const totalUsers = Object.keys(userIdMap).length;
  const maxEngagers = Math.max(0, totalUsers - 1);

  const extraVideos = Array.from({ length: 100 }, (_, idx) => {
    const num = (idx + 1).toString().padStart(3, '0');
    const ownerUsername = ownerUsernames[idx % ownerUsernames.length];
    const category = categories[idx % categories.length];
    const privacy = idx % 10 === 0 ? 'private' : idx % 5 === 0 ? 'followers-only' : 'public';
    const durationSeconds = 22 + (idx % 35); // 22-56 seconds

    // Pick content seed based on category
    const place = places[idx % places.length];
    const pick = (list) => list[idx % list.length];
    let title = `Daily highlight ${num}`;
    let description = `Quick look at highlight ${num}.`;
    let hashtags = ['#snapflow', '#demo'];
    let baseEngagement = 18 + (idx % 18);

    switch (category) {
      case 'travel':
        title = `Sunrise walk in ${place}`;
        description = `Golden hour shots around ${place} with handheld b-roll.`;
        hashtags = ['#travel', '#citywalk', '#goldenhour', `#${place.replace(/\\s+/g, '').toLowerCase()}`];
        baseEngagement += 8;
        break;
      case 'fitness':
        title = `${pick(fitnessIdeas)} playlist`;
        description = `Quick session breakdown + form tips for the ${title.toLowerCase()}.`;
        hashtags = ['#fitness', '#workout', '#formcheck', '#health'];
        baseEngagement += 5;
        break;
      case 'art':
        title = `${pick(artIdeas)} session`;
        description = `Process notes and before/after frames from my latest ${title.toLowerCase()}.`;
        hashtags = ['#art', '#process', '#creative', '#timelapse'];
        baseEngagement += 6;
        break;
      case 'tech':
        title = `${pick(techIdeas)} in 60s`;
        description = `Sharing my go-to ${title.toLowerCase()} with code snippets and screen captures.`;
        hashtags = ['#tech', '#coding', '#flutter', '#devtips'];
        baseEngagement += 4;
        break;
      case 'food':
        title = `${pick(foodIdeas)} prep`;
        description = `Ingredients, timing, and plating for a cozy ${title.toLowerCase()}.`;
        hashtags = ['#food', '#recipe', '#homecooking', '#mealprep'];
        baseEngagement += 5;
        break;
      case 'lifestyle':
        title = `${pick(lifestyleIdeas)} vlog`;
        description = `Mini vlog covering my ${title.toLowerCase()} with quick shots and notes.`;
        hashtags = ['#lifestyle', '#vlog', '#daily', '#minimal'];
        baseEngagement += 3;
        break;
      case 'music':
        title = `Beat sketch ${num}`;
        description = `Layering drums, bass, and a lead hook‚Äîone-take loop.`;
        hashtags = ['#music', '#producer', '#beatmaking', '#loop'];
        baseEngagement += 2;
        break;
      case 'learn':
        title = `Learn: ${pick(techIdeas)}`;
        description = `Quick explainer with 3 takeaways you can try today.`;
        hashtags = ['#learn', '#tutorial', '#quicktips', '#howto'];
        baseEngagement += 3;
        break;
      case 'fashion':
        title = `Outfit grid ${num}`;
        description = `Fits for the week‚Äîmixing staples and thrift finds.`;
        hashtags = ['#fashion', '#ootd', '#style', '#lookbook'];
        baseEngagement += 2;
        break;
      default:
        title = `Daily highlight ${num}`;
        description = `Moments from today‚Äôs shoot and edit.`;
        hashtags = ['#daily', '#creator', '#snapflow', '#vibes'];
    }

    const engagementMultiplier = privacy === 'public' ? 8 : privacy === 'followers-only' ? 5 : 0;
    const maxLikes = Math.min(maxEngagers, Math.max(5, engagementMultiplier)); // cap by users
    const maxComments = Math.min(maxEngagers, 10);

    return {
      id: `demo_video_extra_${num}`,
      ownerUsername,
      title,
      description,
      hashtags,
      privacy,
      durationSeconds,
      likes: engagementMultiplier === 0 ? 0 : Math.min(baseEngagement, maxLikes),
      comments: engagementMultiplier === 0 ? 0 : Math.min(3 + (idx % 9), maxComments),
      views: engagementMultiplier * (baseEngagement + 5),
      shares: engagementMultiplier === 0 ? 0 : Math.min(3 + (idx % 5), Math.max(1, Math.floor(maxEngagers / 3))),
    };
  });

  const demoVideos = [...baseVideos, ...extraVideos];

  const createdVideos = [];
  const errors = [];

  // Small pool of public test HLS URLs to vary demo playback
  // Stable public demo HLS streams that work from mobile apps (m3u8 only, no CORS/access restrictions)
  // Updated Nov 2025 - tested to work from Android/iOS
  const hlsPool = [
    // Mux demo streams
    'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
    'https://test-streams.mux.dev/tos_ismc/main.m3u8',
    // Unified Streaming demo (Tears of Steel)
    'https://demo.unified-streaming.com/k8s/features/stable/video/tears-of-steel/tears-of-steel.ism/.m3u8',
    // Apple demo streams
    'https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8',
    'https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_ts/v1/prog_index.m3u8',
  ];

  const hashString = (value) => {
    let hash = 0;
    for (let i = 0; i < value.length; i++) {
      hash = ((hash << 5) - hash) + value.charCodeAt(i);
      hash |= 0; // keep 32-bit
    }
    return Math.abs(hash);
  };
  
  console.log(`   üìù Creating ${demoVideos.length} demo videos...`);

  for (const videoData of demoVideos) {
    try {
      const ownerId = userIdMap[videoData.ownerUsername];
      if (!ownerId) {
        console.warn(`   ‚ö†Ô∏è  Owner ${videoData.ownerUsername} not found for video ${videoData.id}`);
        errors.push({ videoId: videoData.id, error: 'Owner not found' });
        continue;
      }

      // Pick varied media for realism
      const hash = hashString(videoData.id + videoData.ownerUsername);
      const hlsUrl = hlsPool[hash % hlsPool.length];
      const thumbSeed = encodeURIComponent(videoData.title + hash);
      const thumbnailUrl = `https://images.unsplash.com/photo-1504674900247-0877df9cc836?auto=format&fit=crop&w=720&q=80&sig=${thumbSeed}`;

      // Create video document
      const videoDocData = {
        // Identity
        videoId: videoData.id,
        ownerId: ownerId,
        ownerUsername: videoData.ownerUsername,
        
        // Content
        title: videoData.title,
        description: videoData.description,
        hashtags: videoData.hashtags,
        
        // Video URLs
        hlsUrl,
        thumbnailUrl,
        rawVideoUrl: '', // Not needed for demo
        captionUrl: '', // Optional
        
        // Metadata
        durationSeconds: videoData.durationSeconds,
        width: 720,
        height: 1280,
        aspectRatio: '9:16',
        fileSizeBytes: videoData.durationSeconds * 1000000, // Approximate size in bytes
        
        // Privacy & Status
        privacy: videoData.privacy,
        status: 'ready', // All demo videos are ready
        
        // Engagement metrics
        likesCount: videoData.likes,
        commentsCount: videoData.comments,
        viewsCount: videoData.views,
        sharesCount: videoData.shares,
        savesCount: 0, // Not tracking saves in demo
        
        // Timestamps
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        uploadedAt: admin.firestore.FieldValue.serverTimestamp(),
        
        // Processing flags
        isProcessing: false,
        processingProgress: 100,
        
        // Cloudinary publicId (optional for demo)
        publicId: `demo/${videoData.id}`,
      };

      // Check if video already exists
      const videoDocRef = db.collection('videos').doc(videoData.id);
      const videoDoc = await videoDocRef.get();
      
      if (videoDoc.exists) {
        // Update existing video
        await videoDocRef.update({
          ...videoDocData,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        console.log(`   ‚ôªÔ∏è  Updated video: ${videoData.id} (${videoData.title})`);
      } else {
        // Create new video
        await videoDocRef.set(videoDocData);
        console.log(`   ‚úÖ Created video: ${videoData.id} (${videoData.title}) - ${videoData.privacy}`);
      }

      createdVideos.push({
        id: videoData.id,
        ownerId: ownerId,
        ownerUsername: videoData.ownerUsername,
        title: videoData.title,
        privacy: videoData.privacy,
      });

    } catch (error) {
      errors.push({ videoId: videoData.id, error: error.message });
      console.error(`   ‚ùå Failed to create video ${videoData.id}: ${error.message}`);
    }
  }

  console.log(`\n   Summary: Created ${createdVideos.length} demo videos`);
  if (errors.length > 0) {
    console.log(`   ‚ö†Ô∏è  ${errors.length} errors encountered`);
  }

  return { created: createdVideos.length, videos: createdVideos, errors };
}

/**
 * Step 5: Create Engagement Data
 * Adds likes, comments, and updates engagement counts for demo videos
 */
async function createEngagementData(db, userIdMap, videos) {
  console.log('\nüìã Step 5: Creating engagement data (likes, comments)...');
  
  // Helper function to get random users for engagement
  const getRandomUsers = (count, excludeUsername = null) => {
    const usernames = Object.keys(userIdMap).filter(u => u !== excludeUsername);
    const shuffled = [...usernames].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, usernames.length));
  };

  // Sample comments for different video types
  const commentTemplates = {
    travel: [
      'Wow, this view is incredible! üòç',
      'I need to visit this place!',
      'Amazing cinematography! üì∏',
      'This is on my bucket list now',
      'Beautiful capture! What camera did you use?',
    ],
    fitness: [
      'Great workout! üí™',
      'Thanks for the motivation!',
      'Definitely trying this tomorrow',
      'How many reps do you recommend?',
      'This looks intense! üî•',
    ],
    art: [
      'Your work is amazing! üé®',
      'So creative and inspiring!',
      'What tools do you use?',
      'I love the color palette!',
      'This is pure talent! ‚ù§Ô∏è',
    ],
    tech: [
      'Super helpful tutorial! üíª',
      'Thanks for sharing this!',
      'Where can I learn more?',
      'Great setup! What specs?',
      'This is exactly what I needed',
    ],
    food: [
      'This looks delicious! üçù',
      'Can you share the recipe?',
      'I need to try making this!',
      'My mouth is watering! üòã',
      'You should open a restaurant!',
    ],
    general: [
      'Love this! ‚ù§Ô∏è',
      'This is great content!',
      'Keep it up! üôå',
      'Amazing!',
      'So cool! üî•',
    ],
  };

  // Categorize videos by type for appropriate comments
  const getCommentCategory = (hashtags) => {
    if (hashtags.some(tag => ['travel', 'sunset', 'nature'].includes(tag))) return 'travel';
    if (hashtags.some(tag => ['fitness', 'workout', 'hiit'].includes(tag))) return 'fitness';
    if (hashtags.some(tag => ['art', 'digitalart', 'design'].includes(tag))) return 'art';
    if (hashtags.some(tag => ['coding', 'tech', 'developer'].includes(tag))) return 'tech';
    if (hashtags.some(tag => ['food', 'recipe', 'cooking'].includes(tag))) return 'food';
    return 'general';
  };

  const totalLikesCreated = { count: 0 };
  const totalCommentsCreated = { count: 0 };
  const errors = [];

  console.log(`   üìù Processing ${videos.length} videos for engagement data...`);

  for (const video of videos) {
    try {
      // Skip private videos (no engagement)
      if (video.privacy === 'private') {
        console.log(`   ‚è≠Ô∏è  Skipping private video: ${video.id}`);
        continue;
      }

      // Get video data to determine engagement metrics
      const videoDoc = await db.collection('videos').doc(video.id).get();
      if (!videoDoc.exists) {
        console.warn(`   ‚ö†Ô∏è  Video ${video.id} not found`);
        continue;
      }

      const videoData = videoDoc.data();
      const targetLikes = videoData.likesCount || 0;
      const targetComments = videoData.commentsCount || 0;

      console.log(`   üìπ Processing video: ${video.id} (${targetLikes} likes, ${targetComments} comments)`);

      // Step 5.1: Create like documents
      if (targetLikes > 0) {
        const likers = getRandomUsers(targetLikes, video.ownerUsername);
        
        for (const likerUsername of likers) {
          const likerId = userIdMap[likerUsername];
          if (!likerId) continue;

          const likeDocRef = db.collection('videos').doc(video.id).collection('likes').doc(likerId);
          const likeDoc = await likeDocRef.get();

          if (!likeDoc.exists) {
            await likeDocRef.set({
              userId: likerId,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
            });
            totalLikesCreated.count++;
          }
        }
        
        console.log(`   ‚úÖ Created ${likers.length} likes for ${video.id}`);
      }

      // Step 5.2: Create comment documents
      if (targetComments > 0) {
        const commenters = getRandomUsers(targetComments, video.ownerUsername);
        const commentCategory = getCommentCategory(videoData.hashtags || []);
        const availableComments = commentTemplates[commentCategory] || commentTemplates.general;

        for (let i = 0; i < commenters.length; i++) {
          const commenterUsername = commenters[i];
          const commenterId = userIdMap[commenterUsername];
          if (!commenterId) continue;

          // Get a random comment from the template
          const commentText = availableComments[i % availableComments.length];
          
          // Create comment ID first
          const commentId = `demo_comment_${video.id}_${i + 1}`;
          
          // Create comment data structure
          const commentData = {
            commentId: commentId,
            videoId: video.id,
            authorId: commenterId,
            username: commenterUsername,
            text: commentText,
            likesCount: Math.floor(Math.random() * 5), // Random likes on comments (0-4)
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          };
          
          // Create comment in root-level comments collection
          const commentDocRef = db.collection('comments').doc(commentId);
          const commentDoc = await commentDocRef.get();

          if (!commentDoc.exists) {
            // Create in root comments collection
            await commentDocRef.set(commentData);
            
            // Also create in video subcollection for per-video queries
            const videoCommentDocRef = db.collection('videos').doc(video.id).collection('comments').doc(commentId);
            await videoCommentDocRef.set(commentData);
            
            totalCommentsCreated.count++;
          }
        }

        console.log(`   ‚úÖ Created ${commenters.length} comments for ${video.id} (root collection + subcollection)`);
      }

      // Step 5.3: Reconcile engagement counts (update video doc if mismatch)
      const actualLikesSnapshot = await db.collection('videos').doc(video.id).collection('likes').get();
      const actualCommentsSnapshot = await db.collection('comments').where('videoId', '==', video.id).get();
      
      const planLikes = targetLikes;
      const planComments = targetComments;
      const actualLikes = actualLikesSnapshot.size;
      const actualComments = actualCommentsSnapshot.size;
      
      // Check for mismatches and reconcile
      if (actualLikes !== planLikes || actualComments !== planComments) {
        console.log(`   ‚ö†Ô∏è  Engagement mismatch for ${video.id}:`);
        console.log(`      Plan: ${planLikes} likes, ${planComments} comments`);
        console.log(`      Actual: ${actualLikes} likes, ${actualComments} comments`);
        console.log(`      Reconciling: Updating video document with actual counts...`);
        
        // Update video document with actual counts (only allowed engagement fields + updatedAt)
        const reconciliationUpdates = {
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        };
        if (actualLikes !== planLikes) {
          reconciliationUpdates.likesCount = actualLikes;
        }
        if (actualComments !== planComments) {
          reconciliationUpdates.commentsCount = actualComments;
        }

        await db.collection('videos').doc(video.id).update(reconciliationUpdates);
        
        console.log(`   ‚úÖ Reconciled counts for ${video.id}: ${actualLikes} likes, ${actualComments} comments`);
      } else {
        console.log(`   ‚úÖ Verified counts for ${video.id}: ${actualLikes} likes, ${actualComments} comments (matches plan)`);
      }

    } catch (error) {
      errors.push({ videoId: video.id, error: error.message });
      console.error(`   ‚ùå Failed to create engagement for video ${video.id}: ${error.message}`);
    }
  }

  console.log(`\n   Summary: Created ${totalLikesCreated.count} likes and ${totalCommentsCreated.count} comments`);
  if (errors.length > 0) {
    console.log(`   ‚ö†Ô∏è  ${errors.length} errors encountered`);
  }

  return { 
    likesCreated: totalLikesCreated.count, 
    commentsCreated: totalCommentsCreated.count, 
    errors 
  };
}

/**
 * Step 6: Update User Statistics
 * Updates videosCount for all demo users based on their owned videos
 */
async function updateUserStatistics(db, userIdMap) {
  console.log('\nüìã Step 6: Updating user statistics...');
  
  const errors = [];
  const updatedUsers = [];

  console.log(`   üìù Calculating video counts for ${Object.keys(userIdMap).length} users...`);

  for (const [username, userId] of Object.entries(userIdMap)) {
    try {
      // Query videos owned by this user
      const userVideosSnapshot = await db.collection('videos')
        .where('ownerId', '==', userId)
        .get();
      
      const videoCount = userVideosSnapshot.size;

      // Update user document with videosCount
      await db.collection('users').doc(userId).update({
        videosCount: videoCount,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      updatedUsers.push({ username, userId, videoCount });
      console.log(`   ‚úÖ Updated ${username}: ${videoCount} videos`);

    } catch (error) {
      errors.push({ username, error: error.message });
      console.error(`   ‚ùå Failed to update stats for ${username}: ${error.message}`);
    }
  }

  console.log(`\n   Summary: Updated statistics for ${updatedUsers.length} users`);
  if (errors.length > 0) {
    console.log(`   ‚ö†Ô∏è  ${errors.length} errors encountered`);
  }

  return { updated: updatedUsers.length, userStats: updatedUsers, errors };
}

/**
 * Step 7: Verification and Reporting
 * Verifies all created data and generates comprehensive report
 */
async function verifyDemoData(db, auth, userIdMap) {
  console.log('\nüìã Step 7: Verification and Reporting...');
  
  const expectedUsers = Object.keys(userIdMap).length;
  // Count videos from Firestore instead of hardcoding
  const videosSnap = await db.collection('videos').get();
  const expectedVideos = videosSnap.size;

  const verificationResults = {
    users: { expected: expectedUsers, actual: 0, verified: [] },
    videos: { expected: expectedVideos, actual: 0, verified: [] },
    followers: { expected: 0, actual: 0, relationships: [] },
    following: { expected: 0, actual: 0 },
    likes: { expected: 0, actual: 0 },
    comments: { expected: 0, actual: 0 },
    errors: [],
  };

  try {
    // Step 7.1: Verify Firebase Auth users
    console.log('   üîç Verifying Firebase Auth users...');
    for (const [username, userId] of Object.entries(userIdMap)) {
      try {
        const userRecord = await auth.getUser(userId);
        verificationResults.users.actual++;
        verificationResults.users.verified.push({
          username,
          email: userRecord.email,
          emailVerified: userRecord.emailVerified,
        });
        console.log(`   ‚úÖ Auth user verified: ${userRecord.email}`);
      } catch (error) {
        verificationResults.errors.push({ type: 'auth', username, error: error.message });
        console.error(`   ‚ùå Auth user verification failed for ${username}: ${error.message}`);
      }
    }

    // Step 7.2: Verify Firestore user profiles
    console.log('\n   üîç Verifying Firestore user profiles...');
    let totalFollowers = 0;
    let totalFollowing = 0;
    
    for (const [username, userId] of Object.entries(userIdMap)) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        
        if (!userDoc.exists) {
          verificationResults.errors.push({ type: 'user_profile', username, error: 'User document not found' });
          console.error(`   ‚ùå User profile not found: ${username}`);
          continue;
        }

        const userData = userDoc.data();
        
        // Verify required fields
        const requiredFields = ['uid', 'email', 'username', 'displayName', 'bio', 'videosCount', 'followersCount', 'followingCount'];
        const missingFields = requiredFields.filter(field => !(field in userData));
        
        if (missingFields.length > 0) {
          verificationResults.errors.push({ 
            type: 'user_profile', 
            username, 
            error: `Missing fields: ${missingFields.join(', ')}` 
          });
          console.warn(`   ‚ö†Ô∏è  User ${username} missing fields: ${missingFields.join(', ')}`);
        }

        totalFollowers += userData.followersCount || 0;
        totalFollowing += userData.followingCount || 0;

        console.log(`   ‚úÖ Profile verified: ${username} (${userData.videosCount} videos, ${userData.followersCount} followers, ${userData.followingCount} following)`);
        
      } catch (error) {
        verificationResults.errors.push({ type: 'user_profile', username, error: error.message });
        console.error(`   ‚ùå Profile verification failed for ${username}: ${error.message}`);
      }
    }

    verificationResults.followers.expected = totalFollowers;
    verificationResults.following.expected = totalFollowing;

    // Step 7.3: Verify follower relationships
    console.log('\n   üîç Verifying follower relationships...');
    let followerSubcollectionCount = 0;
    let followingSubcollectionCount = 0;
    
    for (const [username, userId] of Object.entries(userIdMap)) {
      try {
        // Count followers subcollection
        const followersSnapshot = await db.collection('users').doc(userId).collection('followers').get();
        followerSubcollectionCount += followersSnapshot.size;
        
        // Count following subcollection
        const followingSnapshot = await db.collection('users').doc(userId).collection('following').get();
        followingSubcollectionCount += followingSnapshot.size;
        
        verificationResults.followers.relationships.push({
          username,
          followers: followersSnapshot.size,
          following: followingSnapshot.size,
        });
        
        console.log(`   ‚úÖ Relationships verified: ${username} (${followersSnapshot.size} followers, ${followingSnapshot.size} following)`);
        
      } catch (error) {
        verificationResults.errors.push({ type: 'relationships', username, error: error.message });
        console.error(`   ‚ùå Relationship verification failed for ${username}: ${error.message}`);
      }
    }

    // Update actual follower and following counts from subcollections
    verificationResults.followers.actual = followerSubcollectionCount;
    verificationResults.following.actual = followingSubcollectionCount;

    // Step 7.4: Verify demo videos
    console.log('\n   üîç Verifying demo videos...');
    const videosSnapshot = await db.collection('videos')
      .where('videoId', '>=', 'demo_video_')
      .where('videoId', '<=', 'demo_video_\uf8ff')
      .get();
    
    verificationResults.videos.actual = videosSnapshot.size;
    
    for (const videoDoc of videosSnapshot.docs) {
      const videoData = videoDoc.data();
      
      // Verify required fields
      const requiredFields = ['videoId', 'ownerId', 'title', 'description', 'privacy', 'status', 'hlsUrl', 'thumbnailUrl'];
      const missingFields = requiredFields.filter(field => !(field in videoData));
      
      if (missingFields.length > 0) {
        verificationResults.errors.push({ 
          type: 'video', 
          videoId: videoDoc.id, 
          error: `Missing fields: ${missingFields.join(', ')}` 
        });
        console.warn(`   ‚ö†Ô∏è  Video ${videoDoc.id} missing fields: ${missingFields.join(', ')}`);
      }

      verificationResults.videos.verified.push({
        id: videoDoc.id,
        title: videoData.title,
        owner: videoData.ownerUsername,
        privacy: videoData.privacy,
        status: videoData.status,
        likes: videoData.likesCount || 0,
        comments: videoData.commentsCount || 0,
      });

      console.log(`   ‚úÖ Video verified: ${videoDoc.id} (${videoData.title}) - ${videoData.privacy}`);
    }

    // Step 7.5: Verify engagement data and check for mismatches
    console.log('\n   üîç Verifying engagement data...');
    let totalLikes = 0;
    let totalComments = 0;
    let totalPlannedLikes = 0;
    let totalPlannedComments = 0;
    const engagementMismatches = [];
    
    for (const videoDoc of videosSnapshot.docs) {
      const videoId = videoDoc.id;
      const videoData = videoDoc.data();
      
      // Count actual engagement documents
      const likesSnapshot = await db.collection('videos').doc(videoId).collection('likes').get();
      const commentsSnapshot = await db.collection('comments').where('videoId', '==', videoId).get();
      
      const actualLikes = likesSnapshot.size;
      const actualComments = commentsSnapshot.size;
      const plannedLikes = videoData.likesCount || 0;
      const plannedComments = videoData.commentsCount || 0;
      
      totalLikes += actualLikes;
      totalComments += actualComments;
      totalPlannedLikes += plannedLikes;
      totalPlannedComments += plannedComments;
      
      // Check for mismatches between plan and actual
      if (actualLikes !== plannedLikes || actualComments !== plannedComments) {
        engagementMismatches.push({
          videoId,
          title: videoData.title,
          plannedLikes,
          actualLikes,
          plannedComments,
          actualComments,
        });
      }
    }

    verificationResults.likes.expected = totalPlannedLikes;
    verificationResults.likes.actual = totalLikes;
    verificationResults.comments.expected = totalPlannedComments;
    verificationResults.comments.actual = totalComments;

    console.log(`   ‚úÖ Engagement verified: ${totalLikes} total likes, ${totalComments} total comments`);
    
    if (engagementMismatches.length > 0) {
      console.log(`   ‚ö†Ô∏è  Found ${engagementMismatches.length} videos with engagement mismatches`);
      engagementMismatches.forEach(mismatch => {
        console.log(`      - ${mismatch.videoId}: Plan(${mismatch.plannedLikes}L/${mismatch.plannedComments}C) vs Actual(${mismatch.actualLikes}L/${mismatch.actualComments}C)`);
      });
    }

    // Step 7.6: Generate verification report
    console.log('\n' + '='.repeat(60));
    console.log('üìä VERIFICATION REPORT');
    console.log('='.repeat(60));
    
    console.log('\n‚úÖ Firebase Auth Users:');
    console.log(`   Expected: ${verificationResults.users.expected}`);
    console.log(`   Actual: ${verificationResults.users.actual}`);
    console.log(`   Status: ${verificationResults.users.actual === verificationResults.users.expected ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    console.log('\n‚úÖ Firestore User Profiles:');
    console.log(`   Expected: ${verificationResults.users.expected}`);
    console.log(`   Actual: ${verificationResults.users.actual}`);
    console.log(`   Status: ${verificationResults.users.actual === verificationResults.users.expected ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    console.log('\n‚úÖ Follower Relationships:');
    console.log(`   Expected Followers: ${verificationResults.followers.expected}`);
    console.log(`   Actual Followers: ${verificationResults.followers.actual}`);
    console.log(`   Expected Following: ${verificationResults.following.expected}`);
    console.log(`   Actual Following: ${verificationResults.following.actual}`);
    const followersMatch = verificationResults.followers.actual === verificationResults.followers.expected;
    const followingMatch = verificationResults.following.actual === verificationResults.following.expected;
    const bidirectionalMatch = followerSubcollectionCount === followingSubcollectionCount;
    console.log(`   Status: ${followersMatch && followingMatch && bidirectionalMatch ? '‚úÖ PASS (All counts match)' : '‚ùå FAIL (Mismatches detected)'}`);
    if (!followersMatch) {
      console.log(`   ‚ö†Ô∏è  Follower count mismatch: Expected ${verificationResults.followers.expected}, got ${verificationResults.followers.actual}`);
    }
    if (!followingMatch) {
      console.log(`   ‚ö†Ô∏è  Following count mismatch: Expected ${verificationResults.following.expected}, got ${verificationResults.following.actual}`);
    }
    if (!bidirectionalMatch) {
      console.log(`   ‚ö†Ô∏è  Bidirectional mismatch: ${followerSubcollectionCount} followers != ${followingSubcollectionCount} following`);
    }
    console.log('\n‚úÖ Demo Videos:');
    console.log(`   Expected: ${verificationResults.videos.expected}`);
    console.log(`   Actual: ${verificationResults.videos.actual}`);
    console.log(`   Status: ${verificationResults.videos.actual === verificationResults.videos.expected ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    console.log('\n‚úÖ Engagement Data:');
    console.log(`   Total Likes (Plan): ${totalPlannedLikes}`);
    console.log(`   Total Likes (Actual): ${totalLikes}`);
    console.log(`   Total Comments (Plan): ${totalPlannedComments}`);
    console.log(`   Total Comments (Actual): ${totalComments}`);
    const engagementPass = (totalLikes === totalPlannedLikes && totalComments === totalPlannedComments);
    console.log(`   Status: ${engagementPass ? '‚úÖ PASS (Counts match plan)' : '‚ö†Ô∏è  WARNING (Mismatches found - see details above)'}`);
    
    // Privacy distribution
    const privacyDistribution = verificationResults.videos.verified.reduce((acc, video) => {
      acc[video.privacy] = (acc[video.privacy] || 0) + 1;
      return acc;
    }, {});
    
    console.log('\nüìä Video Privacy Distribution:');
    Object.entries(privacyDistribution).forEach(([privacy, count]) => {
      console.log(`   - ${privacy}: ${count} videos`);
    });
    
    // Video ownership distribution
    const ownershipDistribution = verificationResults.videos.verified.reduce((acc, video) => {
      acc[video.owner] = (acc[video.owner] || 0) + 1;
      return acc;
    }, {});
    
    console.log('\nüìä Video Ownership Distribution:');
    Object.entries(ownershipDistribution).forEach(([owner, count]) => {
      console.log(`   - ${owner}: ${count} videos`);
    });
    
    if (verificationResults.errors.length > 0) {
      console.log(`\n‚ö†Ô∏è  Verification Errors (${verificationResults.errors.length}):`);
      verificationResults.errors.forEach(err => {
        console.log(`   - [${err.type}] ${err.username || err.videoId}: ${err.error}`);
      });
    } else {
      console.log('\n‚úÖ All verifications passed with no errors!');
    }

    return verificationResults;

  } catch (error) {
    console.error(`   ‚ùå Verification failed: ${error.message}`);
    verificationResults.errors.push({ type: 'verification', error: error.message });
    return verificationResults;
  }
}

/**
 * Main execution function
 */
async function main() {
  console.log('üöÄ Snapflow Demo Data Seeding Script\n');
  console.log('=' .repeat(60));
  
  try {
    // Step 1: Initialize Firebase Admin SDK
    console.log('\nüìã Step 1: Initializing Firebase Admin SDK...');
    const { projectId, db, auth, bucket } = await initializeFirebase();
    
    // Step 2: Delete E2E Test Videos
    const deleteResult = await deleteE2ETestVideos(db, bucket);
    
    // Step 3: Create Demo User Accounts
    const userResult = await createDemoUsers(db, auth);
    
    // Step 4: Create Demo Videos
    const videoResult = await createDemoVideos(db, userResult.userIdMap);
    
    // Step 5: Create Engagement Data
    const engagementResult = await createEngagementData(db, userResult.userIdMap, videoResult.videos);
    
    // Step 6: Update User Statistics
    const statsResult = await updateUserStatistics(db, userResult.userIdMap);
    
    // Step 7: Verification and Reporting
    const verificationResult = await verifyDemoData(db, auth, userResult.userIdMap);
    
    // Summary
    console.log('\n' + '='.repeat(60));
    console.log('üìä EXECUTION SUMMARY');
    console.log('='.repeat(60));
    console.log(`Project ID: ${projectId}`);
    console.log(`E2E Videos Deleted: ${deleteResult.deleted}`);
    console.log(`Orphaned Comments Deleted: ${deleteResult.orphanedComments || 0}`);
    console.log(`Storage Files Deleted: ${deleteResult.storageFiles || 0}`);
    console.log(`Analytics Documents Deleted: ${deleteResult.analyticsFiles || 0}`);
    console.log(`Demo Users Created: ${userResult.created}`);
    console.log(`Demo Videos Created: ${videoResult.created}`);
    console.log(`Likes Created: ${engagementResult.likesCreated}`);
    console.log(`Comments Created: ${engagementResult.commentsCreated}`);
    console.log(`User Stats Updated: ${statsResult.updated}`);
    console.log(`\nVerification Results:`);
    console.log(`   Auth Users: ${verificationResult.users.actual}/${verificationResult.users.expected}`);
    console.log(`   Videos: ${verificationResult.videos.actual}/${verificationResult.videos.expected}`);
    console.log(`   Engagement: ${verificationResult.likes.actual} likes, ${verificationResult.comments.actual} comments`);
    console.log(`   Errors: ${verificationResult.errors.length}`);
    
    // Display user video counts
    if (statsResult.userStats && statsResult.userStats.length > 0) {
      console.log('\nüìä User Video Counts:');
      statsResult.userStats.forEach(user => {
        console.log(`   - ${user.username}: ${user.videoCount} videos`);
      });
    }
    
    if (deleteResult.errors.length > 0 || userResult.errors.length > 0 || videoResult.errors.length > 0 || engagementResult.errors.length > 0 || statsResult.errors.length > 0) {
      console.log(`\n‚ö†Ô∏è  Total errors encountered: ${deleteResult.errors.length + userResult.errors.length + videoResult.errors.length + engagementResult.errors.length + statsResult.errors.length}`);
      deleteResult.errors.forEach(err => {
        console.log(`   - Video ${err.videoId}: ${err.error}`);
      });
      userResult.errors.forEach(err => {
        console.log(`   - User ${err.email || err.username}: ${err.error}`);
      });
      videoResult.errors.forEach(err => {
        console.log(`   - Video ${err.videoId}: ${err.error}`);
      });
      engagementResult.errors.forEach(err => {
        console.log(`   - Engagement ${err.videoId}: ${err.error}`);
      });
      statsResult.errors.forEach(err => {
        console.log(`   - Stats ${err.username}: ${err.error}`);
      });
    }
    
    console.log('\n‚úÖ Script completed successfully!');
    
    // Final verification status
    const allVerified = 
      verificationResult.users.actual === verificationResult.users.expected &&
      verificationResult.videos.actual === verificationResult.videos.expected &&
      verificationResult.likes.actual === verificationResult.likes.expected &&
      verificationResult.comments.actual === verificationResult.comments.expected &&
      verificationResult.followers.actual === verificationResult.followers.expected &&
      verificationResult.following.actual === verificationResult.following.expected &&
      verificationResult.errors.length === 0;
    
    if (allVerified) {
      console.log('üéâ All data verified successfully! Demo dataset is ready for testing.');
    } else {
      console.log('‚ö†Ô∏è  Some verification checks failed. Please review the errors above.');
    }
    
  } catch (error) {
    console.error('\n‚ùå Script failed with error:');
    console.error(error);
    process.exitCode = 1;
  }
}

// Execute main function
main().catch((err) => {
  console.error('Fatal error:', err);
  process.exitCode = 1;
});
