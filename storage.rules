rules_version = '2';
// Updated: Fixed profile picture upload permissions
service firebase.storage {
  match /b/{bucket}/o {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }


    function getVideoPrivacy(videoId) {
      let videoDoc = firestore.get(/databases/(default)/documents/videos/$(videoId));
      // If the document or privacy field is missing, default to 'private'
      // so that only owner checks (isVideoOwner) can grant access.
      return videoDoc.data != null && videoDoc.data.privacy != null
             ? videoDoc.data.privacy
             : 'private';
    }

    function isVideoOwner(videoId) {
      let videoDoc = firestore.get(/databases/(default)/documents/videos/$(videoId));
      // Allow writes if the video doc does not yet exist (data == null) to avoid
      // race conditions during upload, but enforce owner check when it does.
      return isAuthenticated()
             && (videoDoc.data == null
                 || (videoDoc.data.ownerId != null
                     && request.auth.uid == videoDoc.data.ownerId));
    }

    function isFollower(videoId) {
      let videoDoc = firestore.get(/databases/(default)/documents/videos/$(videoId));
      // Only proceed if we have a video document with an ownerId
      return videoDoc.data != null
             && videoDoc.data.ownerId != null
             && firestore
                  .get(/databases/(default)/documents/users/$(videoDoc.data.ownerId)/followers/$(request.auth.uid))
                  .data != null;
    }

    function isConversationParticipant(conversationId) {
      let conversation = firestore.get(/databases/(default)/documents/conversations/$(conversationId)).data;
      return isAuthenticated() && request.auth.uid in conversation.participants;
    }

    // Return filename base before first dot: 'abc.jpg' -> 'abc'
    function fileBaseName(name) {
      let parts = name.split('.');
      return parts.size() > 0 ? parts[0] : name;
    }

    function isValidVideoFile() {
      // Accept any video content type - be more permissive to avoid upload failures
      return request.resource.contentType.matches('video/.*')
             && request.resource.size < 500 * 1024 * 1024;  // 500 MB
    }

    function isValidImageFile() {
      return request.resource.contentType.matches('image/(jpeg|png|webp|gif)')
             && request.resource.size < 5 * 1024 * 1024;  // 5 MB
    }

    function isValidMessageMedia() {
      return (request.resource.contentType.matches('(image|video)/.*'))
             && request.resource.size < 50 * 1024 * 1024;  // 50 MB
    }

    // Raw Videos (Temporary - Owner-only)
    // Files stored as raw-videos/{userId}/{videoId}.mp4
    match /raw-videos/{userId}/{file} {
      // Allow authenticated owner to write video files
      // Removed strict contentType validation to avoid edge cases with video/mp4 vs video/quicktime etc.
      allow write: if isOwner(userId) && request.resource.size < 500 * 1024 * 1024;
      allow read: if isOwner(userId);
    }

    // Thumbnails (Follow video privacy)
    // Files stored as thumbnails/{videoId}.jpg - enforce owner-only writes
    match /thumbnails/{file} {
      function thumbnailVideoId() {
        return fileBaseName(file);
      }

      // Allow any authenticated user to write valid thumbnail images.
      allow write: if isAuthenticated() && isValidImageFile();

      // Thumbnails are low-sensitivity previews; video playback itself is still
      // protected via Cloudinary signed URLs and Firestore-based privacy.
      // To avoid cross-service race conditions during upload, allow any
      // authenticated user to read thumbnails regardless of privacy.
      allow read: if isAuthenticated();
    }

    // Captions (Follow video privacy, accessible for all)
    // Files stored as captions/{videoId}.vtt
    match /captions/{file} {
      allow write: if false;  // Cloud Functions only
      allow read: if getVideoPrivacy(fileBaseName(file)) == 'public'
                  || isVideoOwner(fileBaseName(file))
                  || (getVideoPrivacy(fileBaseName(file)) == 'followers-only' && isFollower(fileBaseName(file)));
    }

    // Profile Pictures (Owner-write, Authenticated-read)
    // NEW FORMAT: Files stored as profile-pictures/{userId}.jpg
    // Using {userId} wildcard with extension matching instead of fileBaseName function
    match /profile-pictures/{fileName} {
      // Extract userId by checking if the authenticated user's ID matches the filename prefix
      allow write: if isAuthenticated() 
                   && fileName.matches(request.auth.uid + '[.].*')
                   && isValidImageFile();
      allow read: if isAuthenticated();
    }
    
    // LEGACY FORMAT: Files stored as profile-pictures/{userId}/avatar.jpg (or any filename)
    // This supports older profile pictures that used subdirectory structure
    match /profile-pictures/{userId}/{file} {
      allow write: if isOwner(userId) && isValidImageFile();
      allow read: if isAuthenticated();
    }

    // Message Media (Participants-only)
    match /message-media/{conversationId}/{messageId} {
      allow write: if isConversationParticipant(conversationId) && isValidMessageMedia();
      allow read: if isConversationParticipant(conversationId);
    }
  }
}
